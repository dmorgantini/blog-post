This is the first part of a multi-part series of blog posts on Micro-services.  There seems to be a lot of ambiguity amongst the community around what these things are, when they should be used and how to approach them.  This blog series is basically a regurgitation of 5 years of building and learning about micro-services.  I imagine that not everybody will agree with everything I say here, but I hope that there is nothing so controversial as to cause serious disagreements. 
 
Over the past 5 years of my career, I seem orbiting around a single architectural concept.  It has taken me a while (almost 3 years) from the first time I delivered a 'Micro-service' architecture to when I actually knew that it should be called a 'Micro-service' architecture.  Micro-service architectures make sense to me.  Many of the challenges that we face day to day while delivering software systems can be mitigated through the judicious use of micro-services.  

The concepts of micro-services are not new by any stretch of the imagination.  As James Lewis, one of the leading minds in the area, puts it, we are standing on the shoulders of giants.  This architecture is an evolution on things like RPC and SOA and brings concepts that the UNIX world has been building for years into the enterprise architecture space.  Actually defining and bringing the concept to the mainstream has been the work of a few tireless individuals, and this blog series is a tribute to that work.

To date, I have delivered 3 production systems that relied heavily on the micro-services.  I've learnt many things, been burnt many times and finally, after 5 years, I think that I can contribute back to the community some of the things I've learnt.  While I firmly believe that micro-services are a really good way to build flexible, scalable and performant systems I also accept that there are costs involved in choosing this architecture.  It is important for anybody who is choosing micro-services to weigh the costs and benefits against each other.  James Lewis brings these considerations to a head with the following table:
maintainability vs time-to-market
throughput vs cost
portability vs deployability
replacability vs the cost of adding new features
---

The following is a brief history of my time building micro-services.  Enjoy if you're interested.

The first Micro-service architecture that I was part of building was a tightly coupled system that spanned 5 services. It provided essentially a custom built ESB relying heavily on queues for communication.  It was notable only for the very quick development time relative to using a proper ESB.  Unfortunately, due to the tight coupling to MSMQ and a lack of infrastructure automation lead to the service being much more complex than required and reduced the benefits one would hope to get.  Learnings? yep. Micro-services? yep. Best architecture? nope.

The following system I actually had very little to do with the design. It was a RESTful external API for flight prices data.  The data needs for this project were quite complex and nobody was really sure whether the proposed solution would support the API.  Rather than separating the complex data requirements into another service we chose to keep all the code together in a single service.  When the proposed solution turned out to be insufficient, a large amount of rework was required throughout the codebase to change it.  Again, loads of learnings.

The next client I worked on had four services running on simple framework in Java.  They were launched in a single JVM.  As the services did not define a bounded context for their domains(1) logic bled between the services and domain logic found its way into the shared client code.  The tightly coupled services did not provide the flexibility or scalability that one would have hoped for from this type of architecture.  From here came the majority of my learnings with regard to this architecture.  It was a great effort towards micro-services, but did not quite hit the nail on the head.

It was after this project that I discovered DropWizard(2), a java framework that glued together a few awesome Java tools.  While we didn't use DropWizard for the project, when I tried to set up SimpleFramework for a Java talk, I was referred to DropWizard and immediately realised how much simpler it was to set up.  20 minutes and I had a RESTful service ready to go!    

I've now taken to DropWizard and am applying micro-services to my current project. We have 5 services that provide our core functionality and a further 3+ services that will provide support functionality (billing, reporting, audit, etc...).  Notably, our frontend service has been implemented twice (once for user testing written in Ruby and the production version written in Java) and is separated from the integration service(3) providing UI flexibility without risking integration bugs (~500 integrating parties will be in the federation). We were able to rewrite our business process service in ~2 weeks with minimal impact on the rest of the system and we are generally able to make substantial changes to the individual services with minimal impact on the rest of the system. All in all, I'd say that micro-services have given us a substantial boost to our flexibility in the face of uncertainty.  Flexibility, though, always comes at a cost.

(1) See Domain Driven Design (Eric Evans)
(2) http://dropwizard.codahale.com
(3) read at your own risk:  SAML Web SSO Profile 